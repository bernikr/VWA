\section{Kryptografische Prozesse}

Da Bitcoin ohne zentrale Stelle auskommt, müssen die dahinterliegenden Prozesse trotz absoluter Transparenz ein hohes Maß an Sicherheit gewähren.
Hierzu werden hauptsächlich zwei kryptografische Prozesse exzessiv genutzt:
\begin{description}
    \item[Asymmetrische Verschlüsselung] wird benötigt, um Transaktionen signieren zu können und somit um jemanden, der Bitcoins ausgeben möchte zu authentifizieren
    \item[Hashfunktionen] sind ein Wesentlicher Bestandteil der Blockchain, wie auch in Abschnitt \ref{sec:mechanics} erklärt.
\end{description}

\subsection{Asymmetrische Verschlüsselung}

Bei traditionellen symmetrischen Verschlüsselungen, teilen sich Sender und Empfänger einen geheimen Schlüssel, der zum ver- und entschlüsseln verwendet wird.
Beispielsweise möchte Alice eine Nachricht an Bob senden ohne das Eve ihren Inhalt mitbekommt, obwohl sie den gesammten Nachrichtenverkehr zwischen den beiden mitließt.
Wenn die beiden über einen gemeinsamen, Eve nicht bekannten Schlüssel verfügen, so kann Alice ihre Nachricht verschlüsseln, an Bob senden und dieser mit demselben Schlüssel entschlüsseln ohne das Eve den Inhalt erfährt.
Doch wenn sie sich noch nicht über einen gemeinsamen Schlüssel verfügen, ist es schwer sich diesen gegenseitig zukommen zu lassen, ohne dass Eve davon erfährt.

An dieser Stelle setzen \emph{asymetrische Verschlüsselungen} an.
Unter diesen werden Verschlüsselungen verstanden, welche im gegensatz zu symetrischen Schlüsseln unterschiedliche Schlüssel zu Ver- und Entschlüsselung benötigen.
Dies wird meist bewältigt, indem eine Gruppe definiert wird, in welchem das Inverse zu einem gegebenen Wert nicht trivial zu berechnen ist.

Eine \emph{Gruppe} bezeichnet eine abgeschlossene Menge auf der eine assoziative Verknüpfung definiert ist.
Außerdem muss es ein neutrales Element geben und jedes Element ein Inverses aufweisen.
\Cf[182]{schmeh2013}
Beispiele für solche Gruppen ist beispielsweise die Addition in den ganzen Zahlen, die Multiplikation in den reellen Zahlen, die Moduloaddition in einem beliebigen Restlklassenring, sowie die Modulomultiplikation in der Menge $\{ 1, \dotsc, p \mid p \in \mathbb{P}\}$.

In den meisten Gruppen ist das Inverse trivial zu berechnen und es existiert eine brauchbare Umkehrfunktion.
Betrachten wir beispielsweise eine Gruppe über $\mathbb{R}$ mit der Verknüpfung $y=a^x$.
Hier ist die Umkehrfunktion $x=\log_a y$ und das Inverse $x'=\frac{1}{x}$, sodass $a=(a^x)^{x'}$ gilt.
Anders sieht es mit der Moduloexponentialfunktion aus.
Hierbei ist die Umkehrfunktion --~der diskrete Logarithmus~-- für größere Werte mit heutigen Algorithmen nicht in absehbarer Zeit zu berechnen.
Daher ist auch das Inverse nicht diskret berechenbar.
\Cf[184]{schmeh2013}

Um von der asymmetrischen Verschlüsselung Gebrauch zu machen, erstellt Alice Mithilfe einer Hilfsfunktion ein zwei Zahlen, welche über eine definierte Gruppe inverse sind.
Einen der Werte --~den privaten Schlüssel~-- behält Alice für sich und den anderen schickt sie mitsamt der definierten Gruppe an Bob.
Hierbei ist es egal, ob auch andere Personen den Schlüssel erhalten, da dieser öffentlich ist.
Nachdem Bob den öffentlichen Schlüssel von Alice erhalten hat, sind zwei Kryptographische Prozesse möglich:
\begin{enumerate}
    \item Bob verschlüsselt eine Nachricht mit dem öffentlichen Schlüssel und sendet sie an Alice.
    Da nur Alice den privaten Schlüssel hat, kann Eve mit der Nachricht nicht anfangen.
    \item Alice verschlüsselt eine Nachricht (oder einen Hash davon) mit dem privaten Schlüssel.
    Bob, aber auch Eve, kann diese Nachricht nun mit dem öffentlichen Schlüssel entschlüsseln und lesen.
    Da aber nur Alice den privaten Schlüssel inne hat, lässt sich somit die Authentizität der Nachricht überprüfen.
    So kann Bob sich sicher sein, dass diese nicht auf dem Weg verändert wurde.
\end{enumerate}

Die Prozesse der Ver- und Entschlüsselung sind (bis auf den verwendeten Schlüssel) identisch und bestehen nur aus der Anwendung der in der Gruppe definierten Verknüpfung mit dem Schlüssel.
Im Beispiel mit dem Moduloexponential erfolgt die Verschlüsselung eines Klartextes $K$ mit dem öffentlichen Schlüssel $o$ über den Modul $m$ mithilfe von $G \equiv K^o \pmod{m}$.
Die Entschlüsselung erfolgt analog dazu mit dem geheimen Schlüssel $g$: $K \equiv G^g \pmod{m}$.

Die Anwendung bei Bitcoin erfolgt dabei so, dass jeder, der Bitcoins verwenden möchte ein Schlüsselpaar erstellt.
Der öffentliche Schlüssel wird zur Bitcoinadresse.
Möchte man eine Transaktion durchführen, wird diese mit dem privaten Schlüssel signiert.
Daher ist von jedem überprüfbar, ob eine Transaktion auch wirklich von einer Berechtigten Person durchgeführt wurde.

\subsection{Hashfunktion}

Eine Hashfunktion bildet eine Prüfsumme aus einer Nachricht, welche man beispielsweise benutzt, um festzustellen, ob die Nachricht verändert wurde.
\Cf[226]{schmeh2013}
Es wird unterschieden zwischen kryptografischen und nicht-kryptografischen Hashfunktionen.
Eine nicht-kryptografische Hashfunktion liefert eine Prüfsumme, deren Änderung bei Änderung des Urbildes vorhersehbar ist.
So wäre die Quersumme eine einfache nicht-kryptografische Hashfunktion.
Nicht-kryptographische Hashfunktionen finden zum Beispiel als Prüfziffern in Kontonummern, ISBNs und Barcodes vor, wo sie ein irrtümliches Ändern der Nachricht (d.h. Nummer) verhindern sollen.
Vertippt man sich zum Beispiel bei der Eingabe einer Kontonummer, so kann der Computer feststellen, dass die eingegebene Nummer nicht mehr mit der gegebenen Nachricht übereinstimmt und diese als Fehlerhaft markieren.
Hierbei ist bei einer Änderung der Nachricht (auch Urbild genannt) vorhersehbar, wie sich die Prüfsumme ändern wird.
Verringert man zum Beispiel eine Ziffer um 1, so wird auch die Quersumme um 1 weniger.
Folglich lässt sich zu einer gegebenen Zahl ein Urbild finden, das jene als Prüfsumme hat.
\Cfmulti[35f]{schneier}[226]{schmeh2013}

\emph{Kryptografische Hashfunktionen} zeichnen sich dadurch aus, dass man bei gegebenen Hashwert nicht einfach ein Urbild rekonstruieren kann, das jenen erfüllt.
Ebenso soll es mit realistischem Aufwand nicht möglich sein, zwei Urbilder zu finden, die denselben Hashwert haben.
\Cf[289f]{wobst}
Solche Einweg-Hashes erlauben es zum Beispiel Prüfziffern zu erstellen, die nicht nur gegen zufällige Veränderungen Schutz bieten, sondern auch gegenüber böswilligen Angriffen.
Übermittelt man jemanden zum Beispiel eine ausführbare Datei und teilt ihm auf einem sicheren Weg den Hash der Datei mit, kann sich der Empfänger --~sofern die Hashwerte übereinstimmen~-- sicher sein, dass er die Datei unverändert ist.
Denn wenn ein Angreifer zum Beispiel versucht einen Virus in die Datei einzuschleusen, wird sich der Hashwert verändern, egal wie sehr sich der Angreifer bemüht.
